# coding:utf-8

"""
线性时间复杂度和常数空间复杂度

解体思路：
异或：两只不同的值
任何数与0异或结果未任何数
任何数与自己异或结果未零

异或满足结合和交换律

相同为0，不同为1
"""


# 方法一：
nums = [4, 1, 2, 1, 2]
x = 0
for num in nums:
    x ^= num

print(f"只出现一次的数字是{x}")


"""
集合去重后计算元素的和
因为其他袁术都是出现两次，则自己求和的2倍 减去 原数组的和，差就是要找的数

"""

# 方法二：
nums = [4, 1, 2, 1, 2]
x = sum(set(nums))*2 - sum(nums)
print(f"只出现一次的数字是{x}")


"""
遍历元素，计算出现的次数，如果次数为1则为要找的数
"""
# 方法三：
nums = [4, 1, 2, 1, 2]
for num in nums:
    if nums.count(num) == 1:
        print(f"只出现一次的数字是{x}")